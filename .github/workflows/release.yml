name: Build and publish terraform-bundle package

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v1.2.3)'
        required: true
      name:
        description: 'Release name (optional)'
        required: false
      body:
        description: 'Release body/notes (optional)'
        required: false
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4


      - name: Download terraform-bundle binary
        run: |
          set -euo pipefail
          version="0.1.0"
          url="https://github.com/hashicorp-services/terraform-bundle-binary/releases/download/${version}/terraform_bundle_linux_amd64_v0.15.4"
          echo "Downloading terraform-bundle from: $url"
          # -f: fail on HTTP errors; -S: show error; -L: follow redirects; retry to reduce flakiness
          curl -fSL --retry 3 --retry-delay 5 -o terraform-bundle "$url"
          chmod +x terraform-bundle

      - name: Validate downloaded terraform-bundle
        run: |
          set -euo pipefail
          if [ ! -s terraform-bundle ]; then
            echo "Downloaded file is empty" >&2
            exit 1
          fi
          # prefer 'file' output; on runners 'file' should exist
          file_out=$(file --brief terraform-bundle || true)
          echo "file: $file_out"
          # Check for ELF (linux binary) or other executables (Mach-O for mac)
          if echo "$file_out" | grep -Ei "elf|executable|mach-o" >/dev/null; then
            echo "Downloaded terraform-bundle looks like a binary"
          else
            echo "Downloaded terraform-bundle does not look like a native binary. Printing head for debugging:" >&2
            echo "---- BEGIN FILE HEAD ----" >&2
            head -n 50 terraform-bundle >&2 || true
            echo "---- END FILE HEAD ----" >&2
            echo "If this is an HTML error page, the download URL may be incorrect or the release/tag does not exist." >&2
            exit 1
          fi

      - name: Show terraform-bundle version
        run: |
          set -euo pipefail
          ./terraform-bundle -version || true

      - name: Run terraform-bundle package
        run: |
          ./terraform-bundle package -os=linux -arch=amd64 config.hcl

      - name: Collect release artifacts (terraform_*.zip + config.hcl)
        run: |
          set -euo pipefail
          # clean and recreate release-artifacts
          rm -rf release-artifacts
          mkdir -p release-artifacts

          # Find any zip files starting with terraform_ produced anywhere in the workspace
          IFS=$'\n'
          found=()
          while IFS= read -r -d '' f; do
            found+=("$f")
          done < <(find . -type f -name 'terraform_*.zip' -not -path './.git/*' -not -path './.github/*' -print0)

          if [ ${#found[@]} -eq 0 ]; then
            echo "No terraform_*.zip artifacts found after running terraform-bundle package" >&2
            echo "Workspace files (depth 3) for debugging:" >&2
            find . -maxdepth 3 -type f -ls >&2 || true
            exit 1
          fi

          for f in "${found[@]}"; do
            echo "Moving $f to release-artifacts/"
            mv "$f" release-artifacts/ || true
          done

          # Copy config.hcl into release-artifacts so it's included in the release
          if [ -f config.hcl ]; then
            cp config.hcl release-artifacts/config.hcl
          else
            echo "config.hcl not found in repo root" >&2
            ls -la || true
            exit 1
          fi

          echo "Collected files:" 
          ls -la release-artifacts

      - name: Verify artifacts (print to logs)
        run: |
          set -euo pipefail
          if [ ! -d release-artifacts ]; then
            echo "release-artifacts missing" >&2
            exit 1
          fi
          files=(release-artifacts/*)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No artifacts in release-artifacts" >&2
            exit 1
          fi
          echo "Verification report (printing to logs)"
          echo "Generated at: $(date -u)"
          echo ""
          for f in release-artifacts/*; do
            if [ -f "$f" ]; then
              echo "---"
              echo "File: $(basename "$f")"
              echo "Size: $(stat -c%s "$f" 2>/dev/null || stat -f%z "$f") bytes"
              echo "SHA256: $(sha256sum "$f" 2>/dev/null | awk '{print $1}' || shasum -a 256 "$f" | awk '{print $1}')"
              echo "Contents:"
              case "$f" in
                *.zip) unzip -l "$f" || true ;;
                *.tar.gz|*.tgz) tar -tzf "$f" || true ;;
                *.tar) tar -tf "$f" || true ;;
                *) echo "(binary or unknown format)" ;;
              esac
              echo ""
            fi
          done
          echo "Verification complete. (report printed above)"

      - name: Determine release name
        id: release_name
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # prefer inputs.name if provided, otherwise fall back to inputs.tag
            if [ -n "${{ github.event.inputs.name }}" ]; then
              echo "name=${{ github.event.inputs.name }}" >> $GITHUB_OUTPUT
            else
              echo "name=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
            fi
            echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
            echo "body=${{ github.event.inputs.body }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "body=" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release and upload artifacts
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.release_name.outputs.tag }}
          name: ${{ steps.release_name.outputs.name }}
          body: ${{ steps.release_name.outputs.body }}
          files: release-artifacts/**
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
